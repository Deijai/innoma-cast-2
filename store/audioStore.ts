// store/audioStore.ts - STORE DE √ÅUDIO CORRIGIDO
import { Audio, AVPlaybackStatus, AVPlaybackStatusSuccess, InterruptionModeAndroid, InterruptionModeIOS } from 'expo-av';
import { create } from 'zustand';
import { Episode, PlaybackState } from '../types';

interface EnhancedAudioState extends PlaybackState {
    sound: Audio.Sound | null;
    recording: Audio.Recording | null;
    isRecording: boolean;
    recordingDuration: number;
    recordingUri: string | null;

    // Estados aprimorados
    isBuffering: boolean;
    volume: number;
    isMuted: boolean;
    playbackRate: number;
    shouldLoop: boolean;
    progressUpdateInterval: NodeJS.Timeout | null;

    // Configura√ß√µes de qualidade
    audioQuality: 'low' | 'medium' | 'high';
    shouldDuckAudio: boolean;

    // Estados de erro
    errorMessage: string | null;
    lastError: Error | null;

    // Player Actions Aprimoradas
    loadEpisode: (episode: Episode) => Promise<void>;
    play: () => Promise<void>;
    pause: () => Promise<void>;
    stop: () => Promise<void>;
    seekTo: (position: number) => Promise<void>;
    setPlaybackSpeed: (speed: number) => Promise<void>;
    skipForward: (seconds?: number) => Promise<void>;
    skipBackward: (seconds?: number) => Promise<void>;

    // Controles de volume
    setVolume: (volume: number) => Promise<void>;
    toggleMute: () => Promise<void>;

    // Configura√ß√µes avan√ßadas
    setAudioQuality: (quality: 'low' | 'medium' | 'high') => void;
    setLooping: (shouldLoop: boolean) => Promise<void>;

    // Gest√£o de sess√£o
    handleAudioInterruption: (status: AVPlaybackStatus) => void;
    setupAudioSession: () => Promise<void>;

    // Recording Actions (mantidas)
    startRecording: () => Promise<void>;
    stopRecording: () => Promise<string | null>;
    pauseRecording: () => Promise<void>;
    resumeRecording: () => Promise<void>;

    // Utility aprimoradas
    cleanup: () => Promise<void>;
    updatePosition: () => void;
    clearError: () => void;
    resetPlayer: () => void;
}

export const useAudioStore = create<EnhancedAudioState>((set, get) => ({
    // Player State
    isPlaying: false,
    position: 0,
    duration: 0,
    currentEpisode: undefined,
    playbackSpeed: 1.0,
    isLoading: false,
    sound: null,

    // Recording State
    recording: null,
    isRecording: false,
    recordingDuration: 0,
    recordingUri: null,

    // Estados aprimorados
    isBuffering: false,
    volume: 1.0,
    isMuted: false,
    playbackRate: 1.0,
    shouldLoop: false,
    progressUpdateInterval: null,

    // Configura√ß√µes
    audioQuality: 'high',
    shouldDuckAudio: true,

    // Estados de erro
    errorMessage: null,
    lastError: null,

    // CONFIGURA√á√ÉO INICIAL DE √ÅUDIO
    setupAudioSession: async () => {
        try {
            await Audio.setAudioModeAsync({
                staysActiveInBackground: true,
                playsInSilentModeIOS: true,
                shouldDuckAndroid: true,
                playThroughEarpieceAndroid: false,
                allowsRecordingIOS: false,
                interruptionModeIOS: InterruptionModeIOS.DuckOthers,
                interruptionModeAndroid: InterruptionModeAndroid.DuckOthers,
            });
            console.log('‚úÖ Sess√£o de √°udio configurada');
        } catch (error) {
            console.error('‚ùå Erro ao configurar sess√£o de √°udio:', error);
            set({ lastError: error as Error, errorMessage: 'Erro na configura√ß√£o de √°udio' });
        }
    },

    // CARREGAR EPIS√ìDIO APRIMORADO
    loadEpisode: async (episode: Episode) => {
        try {
            set({ isLoading: true, errorMessage: null });

            // Cleanup previous sound
            const { sound: currentSound, progressUpdateInterval } = get();
            if (currentSound) {
                await currentSound.unloadAsync();
            }
            if (progressUpdateInterval) {
                clearInterval(progressUpdateInterval);
            }

            // Configurar sess√£o de √°udio
            await get().setupAudioSession();

            console.log('üéµ Carregando epis√≥dio:', episode.title);
            console.log('üîó URL do √°udio:', episode.audioUrl);

            // Criar e carregar novo som
            const { sound } = await Audio.Sound.createAsync(
                { uri: episode.audioUrl },
                {
                    shouldPlay: false,
                    isLooping: get().shouldLoop,
                    rate: get().playbackSpeed,
                    shouldCorrectPitch: true,
                    volume: get().volume,
                    isMuted: get().isMuted,
                },
                // Callback de status atualizado
                (status) => get().handleAudioInterruption(status)
            );

            // Configurar intervalo de atualiza√ß√£o de progresso
            const interval = setInterval(() => {
                get().updatePosition();
            }, 500); // Atualiza a cada 500ms para suavidade

            set({
                sound,
                currentEpisode: episode,
                position: 0,
                isLoading: false,
                progressUpdateInterval: interval,
                errorMessage: null
            });

            console.log('‚úÖ Epis√≥dio carregado com sucesso');

        } catch (error) {
            console.error('‚ùå Erro ao carregar epis√≥dio:', error);
            set({
                isLoading: false,
                lastError: error as Error,
                errorMessage: 'N√£o foi poss√≠vel carregar o epis√≥dio'
            });
            throw error;
        }
    },

    // CONTROLES DE REPRODU√á√ÉO APRIMORADOS
    play: async () => {
        try {
            const { sound } = get();
            if (sound) {
                await sound.playAsync();
                set({ isPlaying: true, errorMessage: null });
                console.log('‚ñ∂Ô∏è Reprodu√ß√£o iniciada');
            }
        } catch (error) {
            console.error('‚ùå Erro ao reproduzir:', error);
            set({
                lastError: error as Error,
                errorMessage: 'Erro ao reproduzir √°udio'
            });
        }
    },

    pause: async () => {
        try {
            const { sound } = get();
            if (sound) {
                await sound.pauseAsync();
                set({ isPlaying: false });
                console.log('‚è∏Ô∏è Reprodu√ß√£o pausada');
            }
        } catch (error) {
            console.error('‚ùå Erro ao pausar:', error);
            set({
                lastError: error as Error,
                errorMessage: 'Erro ao pausar √°udio'
            });
        }
    },

    stop: async () => {
        try {
            const { sound } = get();
            if (sound) {
                await sound.stopAsync();
                await sound.setPositionAsync(0);
                set({ position: 0, isPlaying: false });
                console.log('‚èπÔ∏è Reprodu√ß√£o parada');
            }
        } catch (error) {
            console.error('‚ùå Erro ao parar:', error);
            set({
                lastError: error as Error,
                errorMessage: 'Erro ao parar √°udio'
            });
        }
    },

    seekTo: async (position: number) => {
        try {
            const { sound, duration } = get();
            if (sound && duration > 0) {
                // Garantir que a posi√ß√£o est√° dentro dos limites
                const clampedPosition = Math.max(0, Math.min(position, duration));
                await sound.setPositionAsync(clampedPosition);
                set({ position: clampedPosition });
                console.log(`‚è≠Ô∏è Posi√ß√£o alterada para: ${clampedPosition}ms`);
            }
        } catch (error) {
            console.error('‚ùå Erro ao buscar posi√ß√£o:', error);
            set({
                lastError: error as Error,
                errorMessage: 'Erro ao alterar posi√ß√£o'
            });
        }
    },

    setPlaybackSpeed: async (speed: number) => {
        try {
            const { sound } = get();
            if (sound) {
                await sound.setRateAsync(speed, true);
                set({ playbackSpeed: speed, playbackRate: speed });
                console.log(`üéõÔ∏è Velocidade alterada para: ${speed}x`);
            }
        } catch (error) {
            console.error('‚ùå Erro ao alterar velocidade:', error);
            set({
                lastError: error as Error,
                errorMessage: 'Erro ao alterar velocidade'
            });
        }
    },

    skipForward: async (seconds = 30) => {
        try {
            const { position, duration } = get();
            const newPosition = Math.min(position + (seconds * 1000), duration);
            await get().seekTo(newPosition);
            console.log(`‚è≠Ô∏è Avan√ßou ${seconds}s`);
        } catch (error) {
            console.error('‚ùå Erro ao avan√ßar:', error);
        }
    },

    skipBackward: async (seconds = 15) => {
        try {
            const { position } = get();
            const newPosition = Math.max(position - (seconds * 1000), 0);
            await get().seekTo(newPosition);
            console.log(`‚èÆÔ∏è Retrocedeu ${seconds}s`);
        } catch (error) {
            console.error('‚ùå Erro ao retroceder:', error);
        }
    },

    // CONTROLES DE VOLUME
    setVolume: async (volume: number) => {
        try {
            const { sound } = get();
            const clampedVolume = Math.max(0, Math.min(volume, 1));

            if (sound) {
                await sound.setVolumeAsync(clampedVolume);
            }

            set({ volume: clampedVolume, isMuted: clampedVolume === 0 });
            console.log(`üîä Volume alterado para: ${Math.round(clampedVolume * 100)}%`);
        } catch (error) {
            console.error('‚ùå Erro ao alterar volume:', error);
            set({
                lastError: error as Error,
                errorMessage: 'Erro ao alterar volume'
            });
        }
    },

    toggleMute: async () => {
        try {
            const { sound, isMuted, volume } = get();

            if (sound) {
                if (isMuted) {
                    // Desmutear - restaurar volume anterior
                    await sound.setVolumeAsync(volume);
                    set({ isMuted: false });
                    console.log('üîä Som desmutado');
                } else {
                    // Mutear - volume zero
                    await sound.setVolumeAsync(0);
                    set({ isMuted: true });
                    console.log('üîá Som mutado');
                }
            }
        } catch (error) {
            console.error('‚ùå Erro ao alterar mudo:', error);
            set({
                lastError: error as Error,
                errorMessage: 'Erro ao alterar som'
            });
        }
    },

    // CONFIGURA√á√ïES AVAN√áADAS
    setAudioQuality: (quality: 'low' | 'medium' | 'high') => {
        set({ audioQuality: quality });
        console.log(`üéõÔ∏è Qualidade de √°udio alterada para: ${quality}`);
    },

    setLooping: async (shouldLoop: boolean) => {
        try {
            const { sound } = get();
            if (sound) {
                await sound.setIsLoopingAsync(shouldLoop);
            }
            set({ shouldLoop });
            console.log(`üîÅ Loop ${shouldLoop ? 'ativado' : 'desativado'}`);
        } catch (error) {
            console.error('‚ùå Erro ao alterar loop:', error);
        }
    },

    // ‚úÖ GEST√ÉO DE INTERRUP√á√ïES - CORRIGIDA
    handleAudioInterruption: (status: AVPlaybackStatus) => {
        // Verificar se o status est√° carregado e tem as propriedades necess√°rias
        if (status.isLoaded) {
            const loadedStatus = status as AVPlaybackStatusSuccess;
            const currentState = get();

            // Atualizar estado baseado no status
            const updates: Partial<EnhancedAudioState> = {
                position: loadedStatus.positionMillis || 0,
                duration: loadedStatus.durationMillis || 0,
                isPlaying: loadedStatus.isPlaying || false,
                isBuffering: loadedStatus.isBuffering || false,
                playbackRate: loadedStatus.rate || 1.0,
            };

            // Detectar fim da reprodu√ß√£o
            if (loadedStatus.didJustFinish && !currentState.shouldLoop) {
                updates.isPlaying = false;
                updates.position = 0;
                console.log('üèÅ Reprodu√ß√£o finalizada');
            }

            set(updates);
        } else {
            // Status n√£o carregado - poss√≠vel erro
            const errorStatus = status as { error?: string };
            if (errorStatus.error) {
                set({
                    errorMessage: 'Erro ao carregar √°udio',
                    lastError: new Error(errorStatus.error),
                    isLoading: false,
                    isPlaying: false
                });
                console.error('‚ùå Erro ao carregar:', errorStatus.error);
            }
        }
    },

    // RECORDING ACTIONS (mantidas do c√≥digo original)
    startRecording: async () => {
        try {
            const { status } = await Audio.requestPermissionsAsync();
            if (status !== 'granted') {
                throw new Error('Permission to record audio denied');
            }

            await Audio.setAudioModeAsync({
                allowsRecordingIOS: true,
                playsInSilentModeIOS: true,
                staysActiveInBackground: true,
                shouldDuckAndroid: true,
                playThroughEarpieceAndroid: false,
            });

            const recording = new Audio.Recording();
            await recording.prepareToRecordAsync(Audio.RecordingOptionsPresets.HIGH_QUALITY);
            await recording.startAsync();

            set({
                recording,
                isRecording: true,
                recordingDuration: 0,
                recordingUri: null
            });

            const interval = setInterval(() => {
                const { isRecording } = get();
                if (!isRecording) {
                    clearInterval(interval);
                    return;
                }
                set(state => ({ recordingDuration: state.recordingDuration + 1000 }));
            }, 1000);

        } catch (error) {
            console.error('Error starting recording:', error);
            set({
                lastError: error as Error,
                errorMessage: 'Erro ao iniciar grava√ß√£o'
            });
            throw error;
        }
    },

    stopRecording: async (): Promise<string | null> => {
        try {
            const { recording } = get();
            if (!recording) return null;

            await recording.stopAndUnloadAsync();
            const uri = recording.getURI();

            await Audio.setAudioModeAsync({
                allowsRecordingIOS: false,
                playsInSilentModeIOS: true,
                staysActiveInBackground: true,
                shouldDuckAndroid: true,
                playThroughEarpieceAndroid: false,
            });

            set({
                recording: null,
                isRecording: false,
                recordingUri: uri,
            });

            return uri;
        } catch (error) {
            console.error('Error stopping recording:', error);
            set({
                lastError: error as Error,
                errorMessage: 'Erro ao parar grava√ß√£o'
            });
            throw error;
        }
    },

    pauseRecording: async () => {
        try {
            const { recording } = get();
            if (recording && recording.pauseAsync) {
                await recording.pauseAsync();
            }
        } catch (error) {
            console.error('Error pausing recording:', error);
        }
    },

    resumeRecording: async () => {
        try {
            const { recording } = get();
            if (recording) {
                await recording.startAsync();
            }
        } catch (error) {
            console.error('Error resuming recording:', error);
        }
    },

    // UTILITIES APRIMORADAS
    cleanup: async () => {
        try {
            const { sound, recording, progressUpdateInterval } = get();

            if (progressUpdateInterval) {
                clearInterval(progressUpdateInterval);
            }

            if (sound) {
                await sound.unloadAsync();
            }

            if (recording) {
                try {
                    await recording.stopAndUnloadAsync();
                } catch (error) {
                    console.log('Recording was already stopped');
                }
            }

            set({
                sound: null,
                recording: null,
                isPlaying: false,
                isRecording: false,
                position: 0,
                duration: 0,
                recordingDuration: 0,
                recordingUri: null,
                currentEpisode: undefined,
                progressUpdateInterval: null,
                isBuffering: false,
                errorMessage: null,
                lastError: null
            });

            console.log('üßπ Cleanup completo do √°udio');
        } catch (error) {
            console.error('‚ùå Erro no cleanup:', error);
        }
    },

    // ‚úÖ UPDATE POSITION - CORRIGIDO
    updatePosition: () => {
        const { sound } = get();
        if (sound) {
            sound.getStatusAsync().then((status) => {
                if (status.isLoaded) {
                    const loadedStatus = status as AVPlaybackStatusSuccess;
                    set({
                        position: loadedStatus.positionMillis || 0,
                        duration: loadedStatus.durationMillis || 0,
                        isPlaying: loadedStatus.isPlaying || false,
                        isBuffering: loadedStatus.isBuffering || false,
                    });
                }
            }).catch(error => {
                console.log('Error getting audio status:', error);
            });
        }
    },

    clearError: () => {
        set({ errorMessage: null, lastError: null });
    },

    resetPlayer: () => {
        const { cleanup } = get();
        cleanup();
        set({
            playbackSpeed: 1.0,
            volume: 1.0,
            isMuted: false,
            shouldLoop: false,
            audioQuality: 'high'
        });
        console.log('üîÑ Player resetado');
    }
}));